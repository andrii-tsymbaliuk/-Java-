# Цимбалюк Андрій ЦК-31 

<p style="text-align: center; font-size:25px">Відповідь на контрольні питання</p>

---

## Питання 1: Порівняння методів сортування

### **Bubble Sort (Сортування бульбашкою)**

**Переваги:**

- Простий для розуміння та реалізації
- Не потребує додаткової пам'яті (сортування на місці)
- Стабільний алгоритм (зберігає відносний порядок рівних елементів)
- Може бути оптимізований для швидкого виявлення вже відсортованих масивів
- Добре працює на майже відсортованих даних (з оптимізацією)

**Недоліки:**

- Дуже повільний на великих масивах
- Найгірша часова складність O(n²)
- Виконує багато порівнянь і обмінів навіть у середньому випадку
- Неефективний для практичного використання на великих даних

---

### **Selection Sort (Сортування вибором)**

**Переваги:**

- Простий для розуміння та реалізації
- Мінімальна кількість обмінів - O(n) обмінів (корисно, якщо операція обміну дорога)
- Не потребує додаткової пам'яті (сортування на місці)
- Передбачувана продуктивність - завжди виконує однакову кількість операцій

**Недоліки:**

- Нестабільний алгоритм (може змінити відносний порядок рівних елементів)
- Завжди виконує O(n²) порівнянь, навіть якщо масив вже відсортований
- Неможливо оптимізувати для частково відсортованих масивів
- Повільний на великих масивах

---

### **Insertion Sort (Сортування вставкою)**

**Переваги:**

- Простий для розуміття та реалізації
- Стабільний алгоритм
- Дуже ефективний на малих масивах (до 10-20 елементів)
- Відмінно працює на майже відсортованих даних - O(n) у найкращому випадку
- Не потребує додаткової пам'яті (сортування на місці)
- Ефективний для онлайн-сортування (коли дані надходять поступово)
- Адаптивний - швидкість залежить від початкового порядку

**Недоліки:**

- Повільний на великих несортованих масивах - O(n²)
- Неефективний, якщо дані відсортовані у зворотному порядку
- Багато операцій зсуву елементів

---

## Питання 2: Оцінка методів за критеріями

### **А) Час роботи (часова складність)**

| Алгоритм           | Найкращий випадок          | Середній випадок | Найгірший випадок |
| ------------------ | -------------------------- | ---------------- | ----------------- |
| **Bubble Sort**    | O(n) - з оптимізацією      | O(n²)            | O(n²)             |
| **Selection Sort** | O(n²)                      | O(n²)            | O(n²)             |
| **Insertion Sort** | O(n) - майже відсортований | O(n²)            | O(n²)             |

**Пояснення:**

- **Bubble Sort**: може виявити відсортований масив за один прохід (з флагом swapped)
- **Selection Sort**: завжди виконує всі порівняння, незалежно від початкового порядку
- **Insertion Sort**: на відсортованому масиві робить лише n-1 порівняння без зсувів

---

### **Б) Потреби у додатковій пам'яті (просторова складність)**

| Алгоритм           | Додаткова пам'ять |
| ------------------ | ----------------- |
| **Bubble Sort**    | O(1)              |
| **Selection Sort** | O(1)              |
| **Insertion Sort** | O(1)              |

**Всі три алгоритми** є алгоритмами сортування "на місці" (in-place) і потребують лише кілька додаткових змінних для зберігання тимчасових значень (temp, indices). Не створюють копії масиву.

---

### **В) Стабільність**

| Алгоритм           | Стабільний? |
| ------------------ | ----------- |
| **Bubble Sort**    | **ТАК**     |
| **Selection Sort** | **НІ**      |
| **Insertion Sort** | **ТАК**     |

**Пояснення стабільності:**

- **Стабільний алгоритм** зберігає відносний порядок рівних елементів
- **Bubble Sort**: міняє місцями лише якщо елементи строго більші/менші (не рівні)
- **Selection Sort**: може переставити рівні елементи при обміні з мінімумом/максимумом
- **Insertion Sort**: вставляє елемент після рівних йому, зберігаючи порядок

**Приклад нестабільності Selection Sort:**

```
Масив: [3a, 2, 3b] (a і b - різні екземпляри 3)
Після сортування: [3b, 3a, 2] - порядок 3a і 3b змінився!
```

---

### **Додаткові критерії порівняння:**

1. **Кількість обмінів:**

   - Bubble Sort: O(n²)
   - Selection Sort: O(n) - мінімум!
   - Insertion Sort: O(n²)

2. **Кількість порівнянь:**

   - Усі три: O(n²) у гіршому випадку

3. **Адаптивність (чутливість до вхідних даних):**

   - Bubble Sort: адаптивний (з оптимізацією)
   - Selection Sort: НЕ адаптивний
   - Insertion Sort: дуже адаптивний

4. **Простота реалізації:**

   - Усі три дуже прості, приблизно однакової складності

5. **Використання кешу процесора:**

   - Insertion Sort: найкращий (послідовний доступ)
   - Bubble Sort: середній
   - Selection Sort: гірший (випадковий доступ при пошуку мінімуму)

6. **Практичне застосування:**
   - Bubble Sort: майже не використовується (тільки в навчанні)
   - Selection Sort: використовується, коли операція обміну дорога
   - Insertion Sort: використовується для малих масивів та як частина гібридних алгоритмів

---

## Питання 3: Найкращі та найгірші випадки

### **Найкращий випадок (Best Case):**

**Вже відсортований масив** у потрібному порядку: `[1, 2, 3, 4, 5]`

| Алгоритм           | Час роботи         | Чому?                                                              |
| ------------------ | ------------------ | ------------------------------------------------------------------ |
| **Bubble Sort**    | O(n) **НАЙКРАЩИЙ** | З оптимізацією робить 1 прохід, не знаходить обмінів і зупиняється |
| **Selection Sort** | O(n²)              | Все одно перевіряє всі елементи для пошуку мінімуму                |
| **Insertion Sort** | O(n) **НАЙКРАЩИЙ** | Кожен елемент вже на своєму місці, робить лише порівняння          |

**Переможці:** Bubble Sort і Insertion Sort (обидва O(n))

---

### **Найгірший випадок (Worst Case):**

**Масив відсортований у зворотному порядку:** `[5, 4, 3, 2, 1]` (коли потрібно за зростанням)

| Алгоритм           | Час роботи          | Чому?                                                    |
| ------------------ | ------------------- | -------------------------------------------------------- |
| **Bubble Sort**    | O(n²)               | Кожен елемент повинен "проплисти" через весь масив       |
| **Selection Sort** | O(n²)               | Виконує стандартну кількість операцій (як завжди)        |
| **Insertion Sort** | O(n²) **НАЙГІРШИЙ** | Кожен елемент треба вставити на початок, максимум зсувів |

**Найгірший результат:** Insertion Sort - кожна вставка вимагає зсуву всіх попередніх елементів

---

### **Частково відсортований масив:**

Наприклад: `[1, 2, 3, 5, 4]` (майже відсортований, лише один елемент не на місці)

| Алгоритм           | Ефективність                |
| ------------------ | --------------------------- |
| **Bubble Sort**    | Добре - O(n) з оптимізацією |
| **Selection Sort** | Погано - все одно O(n²)     |
| **Insertion Sort** | Відмінно - близько до O(n)  |

**Переможець:** Insertion Sort - найкраще працює з частково відсортованими даними

---

### **Масив з багатьма однаковими елементами:**

`[3, 1, 3, 2, 3, 3, 1]`

| Алгоритм           | Особливість                                |
| ------------------ | ------------------------------------------ |
| **Bubble Sort**    | Стабільний - порядок однакових збережеться |
| **Selection Sort** | Нестабільний - може змінити порядок        |
| **Insertion Sort** | Стабільний - порядок однакових збережеться |

---

### **Масив випадкових даних:**

Усі три алгоритми показують O(n²) у середньому, але:

- **Insertion Sort** трохи швидший на практиці через кращу роботу з кешем
- **Selection Sort** робить найменше обмінів

---

### **Підсумкова таблиця:**

| Ситуація               | Найкращий алгоритм    | Найгірший алгоритм |
| ---------------------- | --------------------- | ------------------ |
| Вже відсортований      | Bubble/Insertion Sort | Selection Sort     |
| Зворотній порядок      | Selection Sort        | Insertion Sort     |
| Частково відсортований | Insertion Sort        | Selection Sort     |
| Випадкові дані         | Insertion Sort        | Bubble Sort        |
| Малий масив (<20)      | Insertion Sort        | -                  |
| Дорога операція обміну | Selection Sort        | Bubble Sort        |
| Потрібна стабільність  | Insertion Sort        | Selection Sort     |

---

## Питання 4: Позначення O-нотації

### **Що таке O-нотація (Big O notation)?**

O-нотація описує **асимптотичну складність алгоритму** - як змінюється час виконання або використання пам'яті залежно від розміру вхідних даних (n).

---

### **O(1) - Константна складність**

**Означення:** Час виконання **НЕ залежить** від розміру даних

**Приклади:**

```java
// Отримання елемента масиву за індексом
int element = array[5];  // O(1)

// Додавання двох чисел
int sum = a + b;  // O(1)

// Присвоєння значення
x = 10;  // O(1)
```

**Графік:** Горизонтальна лінія - завжди однаковий час

**Реальний приклад:** Відкрити книгу на сторінці 42 - не важливо, 100 сторінок у книзі чи 1000

---

### **O(n) - Лінійна складність**

**Означення:** Час виконання **прямо пропорційний** розміру даних

**Приклади:**

```java
// Пошук елемента в масиві
for (int i = 0; i < n; i++) {
    if (array[i] == target) return i;
}  // O(n)

// Сума всіх елементів
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += array[i];
}  // O(n)

// Найкращий випадок Bubble Sort (відсортований масив)
```

**Графік:** Пряма лінія під кутом 45° - подвоїли дані, подвоївся час

**Реальний приклад:** Прочитати всю книгу - якщо книга в 2 рази товща, читати вдвічі довше

---

### **O(n²) - Квадратична складність**

**Означення:** Час виконання зростає **пропорційно квадрату** розміру даних

**Приклади:**

```java
// Вкладені цикли (наприклад, Bubble Sort)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // операція
    }
}  // O(n²)

// Порівняння кожного елемента з кожним
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        if (array[i] > array[j]) swap(i, j);
    }
}  // O(n²)
```

**Графік:** Парабола - швидко зростає вгору

**Реальний приклад:** Порівняти кожну людину в кімнаті з кожною іншою для рукостискання - якщо 10 людей = 45 рукостискань, 20 людей = 190 рукостискань

---

### **Порівняльна таблиця швидкості:**

| n (розмір) | O(1) | O(n)   | O(n²)       |
| ---------- | ---- | ------ | ----------- |
| 10         | 1    | 10     | 100         |
| 100        | 1    | 100    | 10,000      |
| 1,000      | 1    | 1,000  | 1,000,000   |
| 10,000     | 1    | 10,000 | 100,000,000 |

**Висновок:** При збільшенні даних в 10 разів:

- O(1): час не змінюється
- O(n): час збільшується в 10 разів
- O(n²): час збільшується в 100 разів!

---

### **Інші популярні O-нотації:**

- **O(log n)** - логарифмічна: бінарний пошук
- **O(n log n)** - лінійно-логарифмічна: швидкі алгоритми сортування (Quick Sort, Merge Sort)
- **O(2ⁿ)** - експоненційна: перебір всіх підмножин
- **O(n!)** - факторіальна: перебір всіх перестановок

---

### **Важливі правила O-нотації:**

1. **Беремо найгірший член:**

   - O(n² + n) → O(n²)
   - O(3n² + 5n + 10) → O(n²)

2. **Ігноруємо константи:**

   - O(5n) → O(n)
   - O(n/2) → O(n)

3. **Описує зростання, а не точний час:**
   - Алгоритм O(n) може бути повільнішим за O(n²) на малих даних
   - Важливо для великих n

---

### **Застосування до наших алгоритмів сортування:**

```
Bubble Sort:
- Найкращий: O(n) - один прохід
- Середній: O(n²) - вкладені цикли
- Найгірший: O(n²) - вкладені цикли

Selection Sort:
- Завжди: O(n²) - завжди два вкладені цикли

Insertion Sort:
- Найкращий: O(n) - без зсувів
- Середній: O(n²) - зсуви в циклі
- Найгірший: O(n²) - максимум зсувів
```

---

## Висновок

Усі три розглянуті алгоритми сортування мають складність O(n²) і підходять лише для малих масивів або навчальних цілей. Для практичного використання на великих даних застосовують швидші алгоритми як Quick Sort або Merge Sort з O(n log n).