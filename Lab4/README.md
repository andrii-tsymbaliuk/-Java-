# Відповіді на контрольні питання

## 1. Чим змінна відрізняється від масиву?

**Змінна** зберігає одне значення певного типу (наприклад, `int x = 5;`), тоді як **масив** — це об'єкт, що зберігає фіксовану кількість елементів одного типу, доступних через індекс (наприклад, `int[] arr = new int[10];`).

## 2. Що таке стек? Що таке купа? Яка між ними різниця?

**Стек (Stack)** — область пам'яті для зберігання локальних змінних методів та посилань. Працює за принципом LIFO (Last In, First Out). Пам'ять автоматично звільняється при виході з методу.

**Купа (Heap)** — область пам'яті для зберігання об'єктів. Керується збирачем сміття (Garbage Collector). Пам'ять живе доти, доки на об'єкт існують посилання.

**Різниця:**

- Стек швидший, але обмежений розміром
- Купа більша, але повільніша
- Стек автоматично очищається, купа потребує GC

## 3. Розташування змінних та масивів у пам'яті

**Змінна:**

- У стеку — примітивні типи (`int`, `double`, `boolean`)
- Безпосередньо у купі — ні
- В об'єкті у купі — поля класів

**Масив:**

- У стеку — ні (масив завжди об'єкт)
- Безпосередньо у купі — так (масив створюється оператором `new`)
- В об'єкті у купі — так (як поле класу)

```java
// Приклад:
void method() {
    int x = 5;           // x у стеку
    int[] arr = new int[5]; // посилання arr у стеку, сам масив у купі
}
```

## 4. Посилання на масив vs масив

**Посилання на масив** — це змінна, що зберігає адресу масиву в пам'яті.

**Масив** — сам об'єкт із даними у купі.

**Розташування посилання:**

- У стеку — локальна змінна методу
- Безпосередньо у купі — ні
- В об'єкті у купі — як поле класу

```java
int[] ref;           // посилання у стеку
ref = new int[10];   // масив у купі
```

## 5. Індекси першої та останньої комірок

Для масиву з 10 комірок:

- **Перша комірка:** індекс `0`
- **Остання комірка:** індекс `9`

Індексація в Java починається з 0.

## 6. Звернення до неіснуючої комірки

Виникне виняток **`ArrayIndexOutOfBoundsException`** під час виконання програми.

```java
int[] arr = new int[5];
int value = arr[10]; // ArrayIndexOutOfBoundsException
```

## 7. Ініціалізація нового масиву

**Спеціальними значеннями за замовчуванням:**

- `0` для числових типів (`int`, `double`)
- `false` для `boolean`
- `null` для посилальних типів

```java
int[] numbers = new int[3];    // {0, 0, 0}
boolean[] flags = new boolean[2]; // {false, false}
String[] strings = new String[2]; // {null, null}
```

## 8. Як дізнатися номер першої та останньої комірки?

```java
int[] arr = new int[10];

int firstIndex = 0;              // завжди 0
int lastIndex = arr.length - 1;  // 9 для цього масиву
```

## 9. Як змінити розмір масиву?

**Неможливо змінити розмір існуючого масиву.** Потрібно створити новий масив і скопіювати дані:

```java
int[] oldArr = new int[5];
int[] newArr = new int[10];

// Копіювання вручну або:
System.arraycopy(oldArr, 0, newArr, 0, oldArr.length);

// Або використати Arrays.copyOf():
newArr = Arrays.copyOf(oldArr, 10);
```

## 10. Що відбувається при копіюванні посилання?

Копіюється тільки **посилання** , а не сам масив. Обидві змінні вказують на один масив у пам'яті.

```java
int[] arr1 = new int[]{1, 2, 3};
int[] arr2 = arr1;  // копіювання посилання

arr2[0] = 100;
System.out.println(arr1[0]); // 100 — зміни видимі через arr1
```

## 11. Що відбувається при втраті посилання?

Масив стає недоступним для програми. **Garbage Collector** автоматично видалить його з пам'яті, коли на нього не залишиться посилань.

```java
int[] arr = new int[100];
arr = null; // втрата посилання — масив буде видалений GC
```

## 12. Різниця між `for` та `for-each`

**Звичайний `for`:**

```java
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

Можна змінювати елементи

Є доступ до індексу

Можна ітерувати у зворотному порядку

Більш багатослівний

**`For-each`:**

```java
for (int element : arr) {
    System.out.println(element);
}
```

Лаконічний та читабельний

Безпечніший (неможливо вийти за межі)

Немає доступу до індексу

Неможливо змінювати елементи масиву

Тільки прямий порядок

## 13. Сумісність типів при записі

**`double[]` ← `int`:** **Так** , відбувається автоматичне розширення типу

```java
double[] arr = new double[3];
arr[0] = 5; // int автоматично конвертується у double (5.0)
```

**`int[]` ← `double`:** **Ні** , потребує явного приведення типу

```java
int[] arr = new int[3];
arr[0] = 5.7; // помилка компіляції
arr[0] = (int) 5.7; // потрібне явне приведення, втрата дробової частини
```