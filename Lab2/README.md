**<h2 align="center">ПЗ-2 Цимбалюк Андрій ЦК-31<h2>**

---

**Тема: Оператори та типи даних**

---

_Хід роботи:_

1. Повторити теоретичні відомості;
2. Виконати три завдання з таблиці 2 відповідно до свого варіанту у таблиці 1;
3. Відповісти на контрольні питання.

---

Варіант №117.

_Вирази №7, №17, №27._

---

Код виконання завдання у файлі Main.

---

## **Відповіді на контрольні питання**

**_№1. В чому полягає різниця між ключовими та зарезервованими словами?_**

Ключові слова – це слова, які вже мають спеціальне значення в Java та використовуються для синтаксису мови (наприклад: class, public, if, for). Їх не можна використовувати як імена змінних, методів або класів.
Зарезервовані слова – це ширше поняття: крім ключових, вони включають слова, зарезервовані на майбутнє, які ще не мають значення,

---

**_№2. Які примітивні типи даних Ви знаєте? Для кожного з них наведіть приклади, коли найбільш ефективно використовувати саме цей тип (наприклад: довжина файлу, кількість зірок на небі, рахунок у футбольному матчі, маса всесвіту, заробітна платня, ...)._**

| **Тип**     | **Розрядність (біт)** | **Діапазон значень**           | **Приклади ефективного використання**                            |
| ----------- | --------------------- | ------------------------------ | ---------------------------------------------------------------- |
| **byte**    | 8                     | -128 … 127                     | Кодування зображень, економія пам’яті у великих масивах.         |
| **short**   | 16                    | -32 768 … 32 767               | Дані з обмеженим діапазоном, наприклад, кількість учнів у школі. |
| **int**     | 32                    | -2 147 483 648 … 2 147 483 647 | Лічильники, розмір файлу у байтах, рахунок у грі.                |
| **long**    | 64                    | ±9×10¹⁸                        | Великі ідентифікатори, маса зірок, час у мілісекундах.           |
| **float**   | 32                    | ~7 значущих цифр               | Приблизні обчислення: фізичні симуляції, графіка.                |
| **double**  | 64                    | ~15 значущих цифр              | Точні розрахунки: фінанси, наукові обчислення.                   |
| **char**    | 16                    | Символи Unicode (0 … 65 535)   | Зберігання окремих символів, наприклад, 'A'.                     |
| **boolean** | 1 (логічно)           | `true` або `false`             | Логічні прапорці, перевірка умов.                                |

---

**_№3. Що таке знакові та беззнакові типи? До якої групи відноситься кожен з примітивних типів даних?_**

- **Знакові типи** — це типи даних, що дозволяють зберігати як додатні, так і від'ємні значення (наприклад, `byte`, `short`, `int`, `long`).
- **Беззнакові типи** — це типи даних, що дозволяють зберігати лише додатні значення (наприклад, `char`, який є беззнаковим типом у Java).

---

**_№4. Яке максимальне число можна записати у змінну типу short, char, int, long?_**

Максимальні значення для примітивних цілих типів у Java:

- **short**: максимальне значення — 32,767.
- **char**: максимальне значення — 65,535.
- **int**: максимальне значення — 2,147,483,647.
- **long**: максимальне значення — 9,223,372,036,854,775,807.

---

**_№5. Змінна типу byte може приймати значення у діапазоні -128..127. Чому цей діапазон саме такий? Чому від’ємних значень більше ніж додатних?_**

byte має 8 біт. Перший біт – знак. Залишається 7 біт для значення:

Максимум: 2⁷–1 = 127.

Мінімум: -2⁷ = -128.
Від’ємних значень на одне більше, бо 0 займає одне з позитивних представлень.

---

**_№6. Що таке система числення? Як переводити значення з однієї системи числення у іншу?_**

Система числення – спосіб запису чисел (десяткова, двійкова, шістнадцяткова).
Переведення:

Для перетворення з десяткової у двійкову – ділимо число на 2, збираючи залишки.

Для зворотного – сумуємо добутки цифр на відповідні степені основи.
У Java є методи Integer.toBinaryString(int n) та Integer.parseInt("1010",2).

---

**_№7. Що таке «Доповняльний код»?_**

Це спосіб подання від’ємних чисел у двійковій системі. Отримується інверсією всіх бітів числа та додаванням 1. Використовується для зручності виконання арифметичних операцій на апаратному рівні.

---

**_№8. Пояснити результат роботи такого фрагмента коду:_**

int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c);

_Оголошення змінних:_

a та b — це дві змінні типу int. У Java int має 32 біти та діапазон від -2 147 483 648 до 2 147 483 647.

Запис 2_000_000_000 — це звичайний синтаксис з підкресленнями для зручності читання, вони не впливають на значення.

_Додавання:_

Результат a + b дорівнює 4 000 000 000.

Це число більше, ніж максимально можливе значення для int. Тому відбувається переповнення (overflow).

_Переповнення:_

У Java переповнення для цілих типів не викликає помилки і не генерує виняток. Замість цього старші біти відкидаються, і результат обчислюється за модулем 2³².

Точний результат:

4 000 000 000 − 4 294 967 296 = −294 967 296

(бо 4 294 967 296 = 2³²).

_Вивід на екран:_

У консоль буде надруковано:

-294967296

_Висновок:_

У Java при перевищенні діапазону int відбувається циклічне переповнення без попередження, і результат стає від’ємним числом. Щоб уникнути цього, треба використовувати тип long або виконувати перевірку перед додаванням:

---

**_№9. Чим тип float відрізняється від double?_**

float – 32 біти, ~7 значущих цифр. Менше місця, менша точність.

double – 64 біти, ~15 значущих цифр. Рекомендовано за замовчуванням для чисел з плаваючою комою.

---

**_№10. Що таке число з рухомою комою? Що таке мантиса та степінь?_**

Число з рухомою комою – представлення числа як мантиси (значущі цифри) та степеня (показник 10 або 2). Наприклад, 6.02×10²³: мантиса 6.02, степінь 23. У двійковій системі Java використовує стандарт IEEE 754.

---

**_№11. Що таке Double.NaN?_**

NaN = «Not a Number». Використовується для позначення результатів невизначених обчислень (наприклад, 0.0/0.0).

---

**_№12. Пояснити результат роботи такого фрагменту коду:
System.out.println(Double.NaN==Double.NaN);_**

Виведе false. Згідно IEEE 754, NaN не дорівнює жодному значенню, навіть самому собі. Перевіряти потрібно через Double.isNaN(x).

---

**_№13.Пояснити різницю між преінкрементом та постінкрементом. Навести приклади, коли ці операції призводять до різних результатів._**

Преінкремент (++x): спочатку збільшує значення, потім використовує його.

Постінкремент (x++): спочатку використовує значення, потім збільшує.
Приклад:

int x = 5;
System.out.println(++x); // 6
x = 5;
System.out.println(x++); // 5 (але тепер x=6)

---

**_№14. . В чому різниця між логічною та побітовою операцією AND? Чому звичайна операція AND (&) є в обох варіантах, а її короткозамкнута версія (&&) лише тільки логічна?_**

&& – логічна операція: зупиняється на першому false (коротке замикання).

& – побітова операція: порівнює кожен біт. Також може діяти як логічне AND без короткого замикання.
Короткозамкнене && існує лише для логічних виразів, бо побітові операції завжди мають обробити всі біти.

---

**_№15. В чому різниця між OR та XOR?_**

OR (|) – повертає 1, якщо хоча б один операнд 1.

XOR (^) – повертає 1, якщо операнди різні.
Приклад:
| A | B | A|B | A^B |
|---|---|-----|-----|
|0|0|0|0|
|0|1|1|1|
|1|0|1|1|
|1|1|1|0|

---

**_№16. Проаналізувати наступний фрагмент програми. Передбачити його результат. Запустити. Пояснити._**

boolean a = true && false | false;
System.out.println(a = false);

boolean b = true && false || false;
System.out.println(b = true);

Вираз true && false → false.

false | false → false. Отже a=false.

Але у System.out.println(a = false) – це присвоєння, тому на екран виведеться false.

У другому випадку: true && false → false.

false || false → false. Отже b=false.

Потім b = true (присвоєння), і виводиться true.

_Вивід у консолі:_

false
true

---